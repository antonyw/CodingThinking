# JVM 类加载机制
一个类从被加载到虚拟机内存开始，到卸载出内存为止，它的整个生命周期包括：
1. 加载
2. 验证
3. 准备
4. 解析
5. 初始化
6. 使用
7. 卸载

其中验证、准备、解析3个部分统称为“连接”。

**加载、验证、准备、初始化和卸载这5个阶段顺序是确定的，而解析则不一定，它在某些情况可以在初始化之后再开始**，这是为了支持Java语言的运行时绑定。

## 何时开启加载？
虚拟机规范严格规定有且只有碰到以下五种情况会立即开启类的加载过程：
1. 遇到 new / getstatic / putstatic / invokestatic 这4条指令时，如果类还没有进行过初始化，则需要先触发其初始化。这4条指令对应的场景是：使用new关键字实例化对象、读取或设置一个类的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）、调用一个类的静态方法时。

2. 使用 java.lang.reflect 包的方法对类进行反射调用的时候，如果类还没有进行过初始化，则需要先触发其初始化。

3. 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。

4. 当虚拟机启动时，用户需要指定一个要执行的主类，虚拟机会先初始化这个主类。

5. 当使用动态语言支持时，如果一个 methodHandler 实例最后解析结果 REF_getStatic / REF_putStatic / REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。

## 类加载过程
下面讲解一下加载、验证、准备、解析、初始化这5个阶段的具体操作。
### 加载
在加载阶段，虚拟机需要完成以下3件事：
1. 通过一个类的全限定名来获取定义此类的二进制字节流。

2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。

3. 在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数的访问入口。

相比较其他4个阶段，加载阶段如果是加载一个非数组类，那么这个过程是开发人员可控性最强的，因为既可以使用系统提供的引导类加载器完成，也可以使用用户自定义的加载器去完成，开发人员可以通过定义自己的类加载器去控制字节流的获取方式（即重写一个类加载器loadClass()方法）。

对于数组类而言，其本身不通过类加载器创建，它是由Java虚拟机直接创建的。但数组类与类加载器仍然有很密切的关系，因为数组类的元素类型最终还要靠类加载器去创建。

加载阶段完成后，虚拟机外部的二进制字节码就按照虚拟机所需的格式存储在方法区中，方法区中的数据存储格式可由虚拟机实现自行定义。然后在内存中实例化一个java.lang.Class对象（并没有明确规定是在Java堆中，**对于HotSpot虚拟机而言，Class对象存放在方法区中**），这个对象将作为程序访问方法区中的这些类型数据的外部接口。

*由此可以延伸出一点，反射。在装载类的时候，加入方法区的所有信息，最后都会集成到Class对象中。也就是说方法区中的所有信息，都可以通过Class对象反射得到。同类的各个对象之间，其实是拥有相同的结构（属性），拥有相同的功能（方法），各个对象的区别只在于属性值的不同。同样的，我们所有的类，其实都是Class类的实例，他们都拥有相同的结构-----Field数组、Method数组。而各个类中的属性都是Field属性的一个具体属性值，方法都是Method属性的一个具体属性值。*

**需要注意的是加载阶段与连接阶段的部分内容（如一部分字节码文件格式验证动作）是交叉进行的**，加载阶段尚未完成，连接阶段可能已经开始，但这些夹在加载阶段之中进行的动作，任然属于连接阶段的内容，这两个阶段的开始时间仍然保持着固定的先后顺序。


### 连接-验证
验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中所包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。

从整体上看，验证阶段大致会完成下面4个阶段的校验动作：文件格式验证、元数据验证、字节码验证、符号引用验证。

### 连接-准备
准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量使用的内存都将在方法区中进行分配。

有两点需要说明：这时候进行内存分配的仅包括类变量（被static修饰的变量），而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中。其次，这里说的初始值是数据类型的零值。即：
```java
public static int value = 123;
```
针对value的初始值是0而不是123，因为这时候尚未开始执行任何Java方法，而value赋值为123的putstatic指令将在初始化阶段才会执行。

当然也存在一些例外情况，如果类字段的字段属性表中存在ConstantValue属性，那么在准备阶段value就会被初始化为ConstantValue属性所制定的值，即
```java
public static final int value = 123;
```
编译时Javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据ConstantValue的设置将value赋值为123。

### 连接-解析
解析阶段是虚拟机将常量池的符号引用替换为直接引用的过程。

#### 符号引用：
*符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义的定位到目标即可。*

#### 直接引用：
*直接引用可以是直接指向目标的指针、相对偏移量或一个能简介定位到目标的句柄。*

### 初始化
初始化阶段是类加载过程的最后一步，此阶段才真正开始执行类中定义的Java程序代码。在准备阶段，变量已经被赋过一次初值，而在初始化阶段，则根据程序员主观定义的类变量来赋值。