# Java内存泄露

### 什么情况会出现内存泄露

#### 1.静态集合类
**例如HashMap LinkedList这种集合容器类**。如果这些容器为静态的，那么它们的生命周期与程序一致，则容器中的对象在程序结束之前将不会被释放，从而造成内存泄露。**简而言之，长生命周期的对象持有短生命周期对象的引用，尽管短生命周期的对象不再使用，但是因为长生命周期对象持有它的引用而导致不能被回收。**

#### 2.各种连接
**例如数据库连接/网络连接/io连接**。当连接不再使用时，需要调用相应的close方法。被关闭的连接才会被回收掉，否则它们会一直存在，从而造成内存泄露。

#### 3.变量不合理的作用域
先看一段代码

```java
public class Test{
	private String msg;
	public void receiveMsg(){
		msg = readFromNet();
		saveDB(msg);	
	}
} 
```

这段代码很简单，从网络上读取msg，然后写入数据库。但其中存在一个很大的问题，msg的生命周期与当前这个Test类相同。实际上当它被写入DB后就没用了，但却不能被回收，这就造成了内存泄露。

#### 4.内部类持有外部类
如果一个外部类的实例对象的方法返回了一个内部类的实例对象，这个内部类对象被长期引用了，即使那个外部类实例对象不再被使用，但由于内部类持有外部类的实例对象，这个外部类对象将不会被垃圾回收，这也会造成内存泄露。

#### 5.改变哈希值
当一个对象被存储进HashSet集合中以后，就不能修改这个对象中的那些参与计算哈希值的字段了，否则，对象修改后的哈希值与最初存储进HashSet集合中时的哈希值就不同了，在这种情况下，即使在contains方法使用该对象的当前引用作为的参数去HashSet集合中检索对象，也将返回找不到对象的结果，这也会导致无法从HashSet集合中单独删除当前对象，造成内存泄露

### 如何排查
1. 下载堆 dump 文件，堆文件都是一些二进制数据，在命令行查看非常麻烦，Java 为我们提供的工具都是可视化的，Linux 服务器上又没法查看，那么首先要把文件下载到本地。
2. 使用 MAT 分析 jvm heap，可以看到各个对象占用多少内存。通常出现了内存泄漏，那这个内存对象一定非常大。
3. 根据上一步拿到的对象，在项目里全局搜索，分析代码。