# InnoDB 引擎中的锁
最近在面试候选人聊到MySQL的InnoDB引擎和MyISAM引擎的区别时，几乎所有人都会说到一点：InnoDB能够支持行级锁，MyISAM只支持表级锁，所以InnoDB效率高一些。

这句话本身并没有问题，通常我会再问一句“InnoDB在任何情况下都能通过行级锁解决数据可能不一致的问题吗？”，可以详细讲下去的候选人似乎并没有多少。感觉更多的人可能是去搜索引擎直接搜“InnoDB和MyISAM的区别”并默记下来，所以才知道这个特性。

这篇文章的目的是想彻底梳理InnoDB引擎中使用的锁，以及不同情况下的不同锁算法。

## 锁类型
### 共享锁与排它锁
InnoDB存储引擎实现了两种的标准的**行级锁**：共享锁（S Lock）和排它锁（X Lock）

共享锁允许事务读一行数据，排它锁允许事务更新或删除一行数据。他们的互相作用如下表

|  | X | S |
| ------ | ------ | ------ |
| X | 不兼容 | 不兼容 |
| S | 不兼容 | 兼容 |

### 意向锁
除此之外，InnoDB还支持更粗粒度的锁，即**表级锁**。InnoDB允许行级锁和表级锁同时存在，称之为意向锁。它的设计思路是如果想获取细粒度的行级锁，需要先获取粗粒度的表级锁。

相应的意向锁也有两种：意向共享锁和意向排它锁。

|  | X | S | IX | IS |
| ------ | ------ | ------ | ------ | ------ |
| X | 不兼容 | 不兼容 | 不兼容 | 兼容 |
| S | 不兼容 | 兼容 | 不兼容 | 兼容 |
| IX | 不兼容 | 不兼容 | 兼容 | 兼容 |
| IS | 不兼容 | 兼容 | 兼容 | 兼容 |

### 自增长锁
几乎所有RDBMS都提供了针对某个键的自增长功能，在并发环境下如何保证数字正确的增长，如何保证不出现多加或少加的情况。其实还是依靠锁机制，InnoDB的实现方式被称为 AUTO-INC Locking。

它的原理是在InnoDB存储引擎的内存结构中，对每个含有自增长值的表都有一个自增长计数器。当对含有自增长计数器的表进行插入操作时，执行如下的语句来得到计数器的值
```sql
select MAX(auto_inc_col) from t for update
```
插入操作会根据这个自增长的计数器值加1赋予自增长列，这就是 AUTO-INC Locking。**这种锁其实是一种表锁机制**，而且锁并不是在一个事务完成之后才释放，它在完成对自增长值插入的SQL语句后就立即释放，这也可以提高插入操作的效率。

值得注意的是，5.1.22版本之后的InnoDB引擎提供了更高效的自增长算法，但需要配合的特定的“插入类型”才可实现，如果有兴趣可以查阅官方文档。当然，上述方式在新版本中也得以保留。

## 锁算法
InnoDB引擎有三种**行锁算法**：

1. Recoder Lock
2. Gap Lock
3. Next-Key Lock

RL总是会去锁住索引记录，如果表在建立的时候没有设置任何一个索引，那么InnoDB会使用隐式主键来进行锁定。

GL会锁定一个范围，但不包括记录本身。

NL是结合了GL和RL的锁算法，这个算法的初衷是为了解决 Phantom Problem（幻象问题）。它不止锁定一个范围，还会锁定记录本身。