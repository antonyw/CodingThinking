# InnoDB 引擎中的锁
最近在面试候选人聊到MySQL的InnoDB引擎和MyISAM引擎的区别时，几乎所有人都会说到一点：InnoDB能够支持行级锁，MyISAM只支持表级锁，所以InnoDB效率高一些。

这句话本身并没有问题，通常我会再问一句“InnoDB在任何情况下都能通过行级锁解决数据可能不一致的问题吗？”，可以详细讲下去的候选人似乎并没有多少。感觉更多的人可能是去搜索引擎直接搜“InnoDB和MyISAM的区别”并默记下来，所以才知道这个特性。

这篇文章的目的是想彻底梳理InnoDB引擎中使用的锁，以及不同情况下的不同锁算法。

## 锁类型
### 共享锁与排它锁
InnoDB存储引擎实现了两种的标准的**行级锁**：共享锁（S Lock）和排它锁（X Lock）

共享锁允许事务读一行数据，排它锁允许事务更新或删除一行数据。他们的互相作用如下表

|  | X | S |
| ------ | ------ | ------ |
| X | 不兼容 | 不兼容 |
| S | 不兼容 | 兼容 |

### 意向锁
除此之外，InnoDB还支持更粗粒度的锁，即**表级锁**。InnoDB允许行级锁和表级锁同时存在，称之为意向锁。它的设计思路是如果想获取细粒度的行级锁，需要先获取粗粒度的表级锁。

相应的意向锁也有两种：意向共享锁和意向排它锁。

|  | X | S | IX | IS |
| ------ | ------ | ------ | ------ | ------ |
| X | 不兼容 | 不兼容 | 不兼容 | 兼容 |
| S | 不兼容 | 兼容 | 不兼容 | 兼容 |
| IX | 不兼容 | 不兼容 | 兼容 | 兼容 |
| IS | 不兼容 | 兼容 | 兼容 | 兼容 |

### 自增长锁
几乎所有RDBMS都提供了针对某个键的自增长功能，在并发环境下如何保证数字正确的增长，如何保证不出现多加或少加的情况。其实还是依靠锁机制，InnoDB的实现方式被称为 AUTO-INC Locking。

它的原理是在InnoDB存储引擎的内存结构中，对每个含有自增长值的表都有一个自增长计数器。当对含有自增长计数器的表进行插入操作时，执行如下的语句来得到计数器的值
```sql
select MAX(auto_inc_col) from t for update
```
插入操作会根据这个自增长的计数器值加1赋予自增长列，这就是 AUTO-INC Locking。**这种锁其实是一种表锁机制**，而且锁并不是在一个事务完成之后才释放，它在完成对自增长值插入的SQL语句后就立即释放，这也可以提高插入操作的效率。

值得注意的是，5.1.22版本之后的InnoDB引擎提供了更高效的自增长算法，但需要配合的特定的“插入类型”才可实现，如果有兴趣可以查阅官方文档。当然，上述方式在新版本中也得以保留。

## 锁算法
InnoDB引擎有三种**行锁算法**：

1. Record Lock 行记录锁
2. Gap Lock 间隙锁
3. Next-Key Lock 临键锁

RL总是会去锁住索引记录，如果表在建立的时候没有设置任何一个索引，那么InnoDB会使用隐式主键来进行锁定。

GL会锁定一个范围，但不包括记录本身。

NKL是结合了GL和RL的锁算法，这个算法的初衷是为了解决 Phantom Problem（幻象问题）。它不止锁定一个范围，还会锁定记录本身。

**注意：三种锁算法都是针对索引记录的。**

## 说了这么多，它们到底怎么用？
众所周知，InnoDB支持四种事务隔离级别：
1. Read Uncommitted
2. Read Committed
3. Repeated Read
4. Serializeble

四种事务隔离级别从上到下，依次升级，依次解决了更多一致性的问题。不妨我们把一致性问题先简单的理解为“读-改-读”的模式，如果一致性做的足够好，那么两次读应该读到相同的数据。下面我们以这个模型进行更详细的说明。

引用很久之前看到的一句话：
> 不同事务的隔离级别，实际上是一致性与并发性的一个权衡与折衷。

**不同的锁策略是实现不同的事务隔离的核心。**

### Read Uncommited
这是一致性最差的事务隔离级别，该级别下默认select不加锁。而且select可以读取到尚未提交的信息，也就产生了“脏读”。

### Read Committed
该级别下默认select使用快照读，因此在update尚未提交的时候，select读取到的信息是不会变的，因此解决了“脏读”问题。

对于加锁select、update、delete，大部分情况下都使用行记录锁（Record Lock）。因此，假如执行
```sql 
select * from t where id > 5 for update;
```
结果有1，2，4。

在该select事务尚未提交时，另一个事务insert了一个3，那么该事务再执行一次相同的select查询到的结果有1，2，3，4。这就是我们说的 Phantom Problem，也有的资料里称作“不可重复读”。

### Repeated Read
该级别下默认select使用快照读，因此在update尚未提交的时候，select读取到的信息是不会变的，因此也能解决了“脏读”问题。

对于加锁select、update、delete，它们如何加锁取决于是否在唯一索引上使用了唯一查询条件，或范围查询条件。
- **存在唯一索引且使用了唯一查询条件**，会使用记录锁(record lock)，而不会封锁记录之间的间隔，即不会使用间隙锁(gap lock)与临键锁(next-key lock)。
- **范围查询条件**，会使用间隙锁(gap lock)与临键锁(next-key lock)，锁住索引记录之间的范围，避免范围间插入记录，以避免产生幻影行记录，以及避免不可重复的读。

### Serializeble
该级别下默认select也都会携带“lock in share mode”，所以即便是读操作也会阻塞其他操作，固能保证很好的一致性，但同时也牺牲了并发性。

---
**不难看出，我们常说的ACID中的I（隔离性）在InnoDB中是由锁来实现的。**